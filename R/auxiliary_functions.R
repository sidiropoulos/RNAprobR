###Auxiliary functions (need to be read-in with a package):
#Stacking offset vectors, used for moving average and moving sum calculations. It forms the matrix with number of rows equivalent to length of sliding window and in each row there is input vector offset by one position:
construct_smoothing_matrix <- function(input_vector, window_size){
	vector_length <- length(input_vector)
	my_mat <- matrix(nrow=window_size, ncol=(vector_length+window_size-1)) #Create empty matrix.
	for(i in 1:(window_size)){my_mat[i,i:(vector_length+i-1)] <- input_vector}   #Fill the matrix, offsetting by 1 in each cycle.
	return(my_mat)
}

#calculating moving average of a vector:
moving_average <- function(input_vector, window_size){
	window_side <- window_size/2-0.5
	return(colMeans(construct_smoothing_matrix(input_vector, window_size), na.rm=T)[(window_side+1):(length(input_vector)+window_side)])
}

#Winsorize a vector:
winsor <- function(input_vector, winsor_level=0.9, only_top=F){ #!!! Function changes integers to numerics!
	bounds <- quantile(input_vector, c((1-winsor_level)/2, 1-(1-winsor_level)/2), names=F, na.rm=T)
	if(only_top){bounds[1] <- 0}
	input_vector[input_vector < bounds[1]] <- bounds[1]
	input_vector[input_vector > bounds[2]] <- bounds[2]
	if((bounds[2]-bounds[1])>0){input_vector <- (input_vector-bounds[1])/(bounds[2]-bounds[1])}else{input_vector[1:length(input_vector)] <- NA}
	return(input_vector)
}

#Sliding-winsorization of a vector:
swinsor_vector <- function(input_vector, window_size, winsor_level=0.9, only_top=F){
	#Define function for aligning matrix generated by construct_smoothing_matrix
	align_smoothing_matrix <- function(input_matrix){
		vector_length <- ncol(input_matrix)-nrow(input_matrix)+1 #Length of the vector used to construct the matrix in construct_smoothing_matrix function.
		my_mat <- matrix(nrow=nrow(input_matrix), ncol=vector_length) #Create empty matrix.
		for(i in 1:nrow(input_matrix)){my_mat[i,] <- input_matrix[i,i:(vector_length+i-1)]}   #Fill the matrix, offseting by -1 in each cycle.
		return(my_mat)
	}
	#End of defining function.
	my_matrix <- construct_smoothing_matrix(input_vector, window_size)
	winsorized_matrix <- apply(my_matrix, 2, winsor, winsor_level=winsor_level, only_top=only_top)
	winsorized_matrix[,c(1:(window_size-1), (length(input_vector)+1):ncol(winsorized_matrix))] <- NA #To control the border behaviour
	aligned_winsorized_matrix <- align_smoothing_matrix(winsorized_matrix)
	means_vector <- colMeans(aligned_winsorized_matrix, na.rm=T)
	sds_vector <- apply(aligned_winsorized_matrix,2, FUN=sd, na.rm=T)
	return(list(means_vector, sds_vector))
}

#Convert GRanges to norm data frame:
GR2norm_df <- function(norm_GR){
	data.frame(RNAid=as.character(seqnames(norm_GR)), Pos=as.integer(start(norm_GR)), mcols(norm_GR))
}

#Convert norm data frame to GRanges:
norm_df2GR <- function(norm_df){
	GRanges(seqnames=norm_df$RNAid, IRanges(start=norm_df$Pos, width=1), strand="+", norm_df[names(norm_df)!="RNAid" & names(norm_df)!="Pos"])
}
